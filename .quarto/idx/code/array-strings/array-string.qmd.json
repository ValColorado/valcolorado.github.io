{"title":"Arrays and Strings","markdown":{"yaml":{"title":"Arrays and Strings","author":"Valentina Colorado","date":"2024-01-28","categories":["Java","Python","Data Structures","Algorithms","Arrays","Strings"],"image":"https://miro.medium.com/v2/resize:fit:1200/1*YWjJuLuXJULb-2IyYhqnXQ.gif","description":"Going over basic arrays and strings content and leetcode problems","format":{"html":{"toc":true,"html-math-method":"katex","css":"styles.css"}}},"headingText":"Arrays and Strings","containsRefs":false,"markdown":"\n\n\n\n\n_Both represent ordered group of elements_ \n\n| Language         | Array and String                               |\n|------------------|------------------------------------------------|\n| Python           | Immutable                                      |\n| Java             | Immutable.                                     |\n| C++              | Mutable                                        |\n\n\n\n\n# Two Pointers\nWorking from the front and back. \n1. Start one pointer at first index 0. and the other pointer at last index input.length-1\n2. while loop until the pointers == each other \n\n\n::: {.panel-tabset}\n\n## Psudocode\n\n``` {.python}\ndef function fn(arr):\n  left =0\n  right = arr.length-1\n  \n  while left < right:\n    So some logic here depending on the problem \n    1. left++\n    2. right--\n    3. both left++ and right-- \n  \n  \n```\n:::\n\n\n> Use two pointers to check if a string is palindrome\n\n::: {.panel-tabset}\n\n## Java\n```{.java}\npublic class Palindrome {\n    public static void main(String[] args) {\n        String s1 = \"racecar\";\n\n        System.out.println(checkIfPalindrome(s1));\n    }\n        \n    public static boolean checkIfPalindrome(String s1){\n        int left =0;\n        int right = s1.length()-1;\n\n        while(left<right){\n            if(s1.charAt(left)== s1.charAt(right)){\n                left++;\n                right--;\n                \n            }\n            else{\n                return false;\n            }\n        }\n        return true;\n\n    }\n}\n\n```\n\n## Python\n```{.python}\ndef main():\n      s = \"racecar\"\n      print(checkIfPalindrome(s))\n\ndef checkIfPalindrome(s: str) -> bool:\n\n    left =0\n    right = len(s)-1\n\n    while left<right:\n        \n        if(s[left] == s[right]):\n            left += left\n            right -= right\n                \n        else:\n            return False;\n                \n            \n    return True;\n\n\n```\n\n::: \n\n_Time: O(n) Space:O(1)_\n\n> Example 2: Given a sorted array of unique integers and a target integer, return true if there exists a pair of numbers that sum to target, false otherwise. This problem is similar to Two Sum. (In Two Sum, the input is not sorted).\n For example, given nums = [1, 2, 4, 6, 8, 9, 14, 15] and target = 13, return true because 4 + 9 = 13.\n \n\n::: {.panel-tabset}\n\n## Java\n```{.java}\n    public static boolean targetSum(int[] nums,int target){\n\n        int left =0;\n        int right = nums.length-1;\n\n\n        while(left<right){\n            int sum = nums[left]+nums[right];\n            if(sum == target){\n                return true; \n            }\n            else if(sum>target){\n                right--;\n\n            }\n            else{\n                left++;\n            }\n    }\n    return false;\n        \n\n    }\n```\n\n## Python\n```{.python}\ndef targetSum(nums:list[int], target:int ) -> bool:\n\n    left =0\n    right = len(nums)-1\n\n\n    while left<right:\n         sum = nums[left]+nums[right]\n         if(sum == target):\n            return True\n         elif(sum>target):\n             right -=1\n         else:\n             left += 1\n    return False\n```\n::: \n\n_Time: O(n) Space:O(1)_\n\n> Example 3: Given two sorted integer arrays arr1 and arr2, return a new array that combines both of them and is also sorted.\n\n\n::: {.panel-tabset}\n## Java\n```{.java}\npublic static List<Integer> combinedSorted(int[] arr1, int[]arr2){\n\n        \n        List<Integer>  arr3 = new ArrayList<>();\n        int i =0;\n        int j =0;\n\n        while(i <arr1.length && j<arr2.length){\n            if(arr1[i]<arr2[j]){\n                arr3.add(arr1[i]);\n                i++;\n            }\n            else{\n                arr3.add(arr2[j]);\n                j++;\n            }\n            \n        }\n        // After the first while loop one of the arrays will have gone through completly\n        while (i < arr1.length) {\n            arr3.add(arr1[i]);\n            i++;\n        }\n    \n        while (j < arr2.length) {\n            arr3.add(arr2[j]);\n            j++;\n        }\n    \n        return arr3;\n    }\n}\n\n\n```\n\n:::\n\n_Time: O(n) Space:O(1)_\n\n>Example 4: 392. Is Subsequence.\nGiven two strings s and t, return true if s is a subsequence of t, or false otherwise.\n\n::: {.panel-tabset}\n## Java\n```{.java}\n\n public static boolean checkIfSubsequence(String s, String t){\n    int i =0;\n    int j =0;\n\n    while(i < s.length() && j<t.length()){\n        if(s.charAt(i)==t.charAt(j)){\n            i++;\n        }\n         \n        j++;\n        \n    }\n    return i == s.length();\n }\n\n}\n```\n\n:::\n\n_Time: O(n) Space:O(1)_\n\nA subsequence of a string is a sequence of characters that can be obtained by deleting some (or none) of the characters from the original string, while maintaining the relative order of the remaining characters. For example, \"ace\" is a subsequence of \"abcde\" while \"aec\" is not.\n\n\n## Two Pointers Examples\n\n>Reverse String Write a function that reverses a string. The input string is given as an array of characters s.\nYou must do this by modifying the input array in-place with O(1) extra memory\n\n\n::: {.panel-tabset}\n\n## Java\n\n```{.java}\n public static void reverseString(char[] s) {\n        int i = s.length-1; \n        int j= 0; \n        \n        while(i > j ){\n            char tmp = s[j];\n            s[j++]=s[i];\n            s[i--]=tmp;\n        }\n        System.out.println(s);\n        \n    }   \n```\n\n## Python\n```{.python}\n\nclass Solution(object):\n    def reverseString(self, s):\n    s.reverse()\n```\n\n:::\n\n>**Squares of a Sorted Array**\nGiven an integer array nums sorted in non-decreasing order, return an array of the squares of each number sorted in non-decreasing order.\n\n\n::: {.panel-tabset}\n\n## Java\n\n```{.java}\n    public int[] sortedSquares(int[] nums) {\n        \n        int left = 0;\n        int right = nums.length-1;\n\n        while(left <= right){\n        \n            int tmp = nums[left]*nums[left];\n            nums[left] = tmp;\n            left++;\n        }\n        Arrays.sort(nums);\n\n        return nums;\n    }\n```\n\n## Java\n```{.java}\n//After my first submission I realized this could be cleaner\n    public int[] sortedSquares(int[] nums) {\n        for(int i=0; i< nums.length;i++){\n            nums[i] = nums[i] * nums[i];\n        }\n        Arrays.sort(nums);\n        return nums;\n    }\n```\n## Python\n```{.python}\ndef sortedSquares(self, nums: List[int]) -> List[int]:\n  for i in range(len(nums)):\n      nums[i] = nums[i] *nums[i]\n  nums = sorted(nums)\n  return nums\n```\n\n:::\n\n# Sliding Window \n_Similar to two pointers they're iterables with ordered elements._\n\n## Subarrays\n\nContinuous section of the array. All the elements must be **adjacent to each other and in their original order**\n\nExample: [1,2,3,4]\n\n- [1],[2],[3],[4]\n- [1,2],[2,3],[3,4]\n- [1,2,3], [2,3,4]\n\n\nIdentifying when to use this:\n\nThe problem will:\n  1. Explicitly or implicitly define criteria that makes a subarray \"valid\". \n  2. Ask you to find valid subarrays in some way \n    - find the \"best\" valid subarray \n    - finding the number of valid subarrays \n    \n## Psudocode\n```{.java}\nfunction fn(nums, k):\n    left = 0\n    curr = 0\n    answer = 0\n    for (int right = 0; right < nums.length; right++):\n        curr += nums[right]\n        while (curr > k):\n            curr -= nums[left]\n            left++\n\n        answer = max(answer, right - left + 1)\n\n    return answer\n```\n\n>Example 1: Given an array of positive integers nums and an integer k, find the length of the longest subarray whose sum is less than or equal to k. This is the problem we have been talking about above. We will now formally solve it.\n\n\n## Java\n```{.java}\n    public static int subarray(int[] nums, int k) {\n        int left =0;\n        int sum = 0;\n        int answer = 0;\n\n        for(int right =0; right<nums.length;right++){\n            sum += nums[right];\n            while(sum > k){\n                sum -= nums[left];\n                left++;\n            }\n            answer = Math.max(answer, right - left + 1);\n\n        }\n```\n\n>Example 2: You are given a binary string s (a string containing only \"0\" and \"1\"). You may choose up to one \"0\" and flip it to a \"1\". What is the length of the longest substring achievable that contains only \"1\"?\nFor example, given s = \"1101100111\", the answer is 5. If you perform the flip at index 2, the string becomes 1111100111.\n\n::: {.panel-tabset}\n\n## Java\n\n```{.java}\npublic static int binarySubarray(String s) {\n    int left =0;\n    int counter = 0;\n    int answer = 0;\n\n    for(int i =0; i<s.length();i++){\n        if (s.charAt(i)== '0') {\n            counter++;\n\n        }\n\n        while(counter > 1){\n            if (s.charAt(left) == '0') {\n                counter--;\n            }\n\n            left++;\n        }\n\n        answer = Math.max(answer, i - left + 1);\n    }\n\n        \n        return answer;\n\n    }\n\n```\n\n## Python\n```{.python}\ndef binarySubarray(s):\n\n    left=counter=answer=0\n\n    for i in range(len(s)):\n        if s[i] ==\"0\":\n            counter +=1\n        while counter > 1:\n            if(s[left] == \"0\"):\n                counter -= 1\n            left += 1\n\n        ans = max(answer, i - left + 1)\n\n    return(ans)\n```\n\n:::\n\n## Number of Subarrays\n>**Example 3: 713. Subarray Product Less Than K.**\nGiven an array of positive integers nums and an integer k, return the number of subarrays where the product of all the elements in the subarray is strictly less than k.\nFor example, given the input nums = [10, 5, 2, 6], k = 100, the answer is 8. The subarrays with products less than k are:[10], [5], [2], [6], [10, 5], [5, 2], [2, 6], [5, 2, 6]\n\n```{.java}\npublic static int productLessThan(int[] nums, int k) {\n        int left =0;\n        int counter = 1;\n        int answer = 0;\n\n        if (k <= 1) {\n            return 0;\n        }\n        for(int right =0; right<nums.length;right++){\n            counter *= nums[right];\n            while(counter>=k){\n                counter /= nums[left]; //opposite of multiplication remove that element \n                left += 1;\n            }\n            answer += right -left +1;\n    }\n        return answer;\n\n    }\n\n```\n\n\n## Fixed window size\n\n## Psudocode\n```{.java}\nfunction fn(arr, k):\n    curr = some data to track the window\n\n    // build the first window\n    for (int i = 0; i < k; i++)\n        Do something with curr or other variables to build first window\n\n    ans = answer variable, probably equal to curr here depending on the problem\n    for (int i = k; i < arr.length; i++)\n        Add arr[i] to window\n        Remove arr[i - k] from window\n        Update ans\n\n    return ans\n```\n\n## Leetcode Problem \n\n>**Example 4**: Given an integer array nums and an integer k, find the sum of the subarray with the largest sum whose length is k.\n\n```{.java}\npublic static int productLessThan(int[] nums, int k) {\n        int left =0;\n        int counter = 1;\n        int answer = 0;\n\n        if (k <= 1) {\n            return 0;\n        }\n        for(int right =0; right<nums.length;right++){\n            counter *= nums[right];\n            while(counter>=k){\n                counter /= nums[left]; //opposite of multiplication remove that element \n                left += 1;\n            }\n            answer += right -left +1;\n    }\n        return answer;\n\n    }\n\n```\n\n\n**1004. Max Consecutive Ones III**: Given a binary array nums and an integer k, return the maximum number of consecutive 1's in the array if you can flip at most k 0's.\n\nExample 1:\nInput: nums = [1,1,1,0,0,0,1,1,1,1,0], k = 2\nOutput: 6\nExplanation: [1,1,1,0,0,**1**,1,1,1,1,**1**]\nBolded numbers were flipped from 0 to 1. The longest subarray is underlined..\n\n\n::: {.panel-tabset}\n\n## Java\n```{.java}\npublic static int productLessThan(int[] nums, int k) {\n        int left =0;\n        int counter = 1;\n        int answer = 0;\n\n        if (k <= 1) {\n            return 0;\n        }\n        for(int right =0; right<nums.length;right++){\n            counter *= nums[right];\n            while(counter>=k){\n                counter /= nums[left]; //opposite of multiplication remove that element \n                left += 1;\n            }\n            answer += right -left +1;\n    }\n        return answer;\n\n    }\n\n```\nTime complexity:O(n) Space complexity:O(1) _3ms Runtime Beats 79.28% of users with Java_\n:::\n\n\n# Prefix Sum\nPrefix sum is a technique that can be used on arrays (of numbers). The idea is to create an array prefix where prefix[i] is the sum of all elements up to the index i (inclusive). For example, given nums = [5, 2, 1, 6, 3, 8], we would have prefix = [5, 7, 8, 14, 17, 25].\n\n\n If we want the sum of the subarray from i to j (inclusive), then the answer is prefix[j] - prefix[i - 1], or prefix[j] - prefix[i] + nums[i] if you don't want to deal with the out of bounds case when i = 0.\n \n \n```{.java}\npublic boolean[] answerQueries(int[] nums, int[][] queries, int limit) {\n    int[] prefix = new int[nums.length];\n    prefix[0] = nums[0];\n\n    for (int i = 1; i < nums.length; i++) {\n        prefix[i] = prefix[i - 1] + nums[i];\n    }\n\n    boolean[] ans = new boolean[queries.length];\n    for (int i = 0; i < queries.length; i++) {\n        int x = queries[i][0], y = queries[i][1];\n        int curr = prefix[y] - prefix[x] + nums[x];\n        ans[i] = curr < limit;\n    }\n    \n    return ans;\n}\n```\n\n## Leetcode Problem \nGiven an array nums. We define a running sum of an array as runningSum[i] = sum(nums[0]…nums[i]). **Return the running sum of nums**\n\nExample 1:\nInput: nums = [1,2,3,4]\nOutput: [1,3,6,10]\nExplanation: Running sum is obtained as follows: [1, 1+2, 1+2+3, 1+2+3+4].\n\n::: {.panel-tabset}\n\n## Java\n```{.java}\n    private static int[] runningSum(int[] nums) {\n        int [] prefix = new int[nums.length];\n        prefix[0]=nums[0];\n        for(int i=1;i<nums.length;i++){\n            prefix[i] = nums[i]+prefix[i-1];\n        }\n        return prefix;\n\n    }\n\n```\nTime complexity:O(n) Space complexity:O(n) **It creates an additional array prefix of the same length as the input array nums. The size of the prefix array is proportional to the size of the input array, making the space complexity linear.**\n\n_Runtime 0ms Beats100.00% of users with Java_\n::: \n\n\n# More Common Patters\n\n## O(n) String Building\n::: {.panel-tabset}\n\n## Python\n```{.python}\ndef build_string(s):\n  arr=[] #declar a list\n  for c in s\n      arr.append(c) #add the characters to the list \n    return \"\".join(list) # convert the list to a string \n\n```\n_O(n)_\n\n## Java\n```{.java}\npublic string buildString(String s) {\n    StringBuilder sb = new StringBuilder(); //use string builder\n    for (int i = 0; i < s.length(); i++) {\n        sb.append(s.charAt(i)); // add character to the list\n    }\n    StringBuilder.toString() // convert list to string\n    return sb.toString();\n\n    \n```\n_O(n)_\n::: \n\n# Extra Leetcode Problems\n\n557. Reverse Words in a String III\nGiven a string s, reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.\n\n>Example 1:\nInput: s = \"Let's take LeetCode contest\"\nOutput: \"s'teL ekat edoCteeL tsetnoc\"\nExample 2:\n\n>Input: s = \"Mr Ding\"\nOutput: \"rM gniD\"\n\n\n::: {.panel-tabset}\n\n## Java\n```{.java}\nprivate static String reverseWords(String s) {\n\n        StringBuilder sb = new StringBuilder();\n        \n        int left=0;\n\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == ' ') {\n                // Reverse the word and append to StringBuilder\n                for (int j = i - 1; j >= left; j--) {\n                    sb.append(s.charAt(j));\n                }\n                // Append the space\n                sb.append(' ');\n                // Update the left pointer to the next character\n                left = i + 1;\n            } else if (i == s.length() - 1) {\n                // Reverse the last word and append to StringBuilder\n                for (int j = i; j >= left; j--) {\n                    sb.append(s.charAt(j));\n                }\n            }\n        }\n    \n        return sb.toString();\n\n        }\n```\n_Runtime 9ms Beats 44.51% of users with Java_\n::: \n\n","srcMarkdownNoYaml":"\n\n\n# Arrays and Strings\n\n\n_Both represent ordered group of elements_ \n\n| Language         | Array and String                               |\n|------------------|------------------------------------------------|\n| Python           | Immutable                                      |\n| Java             | Immutable.                                     |\n| C++              | Mutable                                        |\n\n\n\n\n# Two Pointers\nWorking from the front and back. \n1. Start one pointer at first index 0. and the other pointer at last index input.length-1\n2. while loop until the pointers == each other \n\n\n::: {.panel-tabset}\n\n## Psudocode\n\n``` {.python}\ndef function fn(arr):\n  left =0\n  right = arr.length-1\n  \n  while left < right:\n    So some logic here depending on the problem \n    1. left++\n    2. right--\n    3. both left++ and right-- \n  \n  \n```\n:::\n\n\n> Use two pointers to check if a string is palindrome\n\n::: {.panel-tabset}\n\n## Java\n```{.java}\npublic class Palindrome {\n    public static void main(String[] args) {\n        String s1 = \"racecar\";\n\n        System.out.println(checkIfPalindrome(s1));\n    }\n        \n    public static boolean checkIfPalindrome(String s1){\n        int left =0;\n        int right = s1.length()-1;\n\n        while(left<right){\n            if(s1.charAt(left)== s1.charAt(right)){\n                left++;\n                right--;\n                \n            }\n            else{\n                return false;\n            }\n        }\n        return true;\n\n    }\n}\n\n```\n\n## Python\n```{.python}\ndef main():\n      s = \"racecar\"\n      print(checkIfPalindrome(s))\n\ndef checkIfPalindrome(s: str) -> bool:\n\n    left =0\n    right = len(s)-1\n\n    while left<right:\n        \n        if(s[left] == s[right]):\n            left += left\n            right -= right\n                \n        else:\n            return False;\n                \n            \n    return True;\n\n\n```\n\n::: \n\n_Time: O(n) Space:O(1)_\n\n> Example 2: Given a sorted array of unique integers and a target integer, return true if there exists a pair of numbers that sum to target, false otherwise. This problem is similar to Two Sum. (In Two Sum, the input is not sorted).\n For example, given nums = [1, 2, 4, 6, 8, 9, 14, 15] and target = 13, return true because 4 + 9 = 13.\n \n\n::: {.panel-tabset}\n\n## Java\n```{.java}\n    public static boolean targetSum(int[] nums,int target){\n\n        int left =0;\n        int right = nums.length-1;\n\n\n        while(left<right){\n            int sum = nums[left]+nums[right];\n            if(sum == target){\n                return true; \n            }\n            else if(sum>target){\n                right--;\n\n            }\n            else{\n                left++;\n            }\n    }\n    return false;\n        \n\n    }\n```\n\n## Python\n```{.python}\ndef targetSum(nums:list[int], target:int ) -> bool:\n\n    left =0\n    right = len(nums)-1\n\n\n    while left<right:\n         sum = nums[left]+nums[right]\n         if(sum == target):\n            return True\n         elif(sum>target):\n             right -=1\n         else:\n             left += 1\n    return False\n```\n::: \n\n_Time: O(n) Space:O(1)_\n\n> Example 3: Given two sorted integer arrays arr1 and arr2, return a new array that combines both of them and is also sorted.\n\n\n::: {.panel-tabset}\n## Java\n```{.java}\npublic static List<Integer> combinedSorted(int[] arr1, int[]arr2){\n\n        \n        List<Integer>  arr3 = new ArrayList<>();\n        int i =0;\n        int j =0;\n\n        while(i <arr1.length && j<arr2.length){\n            if(arr1[i]<arr2[j]){\n                arr3.add(arr1[i]);\n                i++;\n            }\n            else{\n                arr3.add(arr2[j]);\n                j++;\n            }\n            \n        }\n        // After the first while loop one of the arrays will have gone through completly\n        while (i < arr1.length) {\n            arr3.add(arr1[i]);\n            i++;\n        }\n    \n        while (j < arr2.length) {\n            arr3.add(arr2[j]);\n            j++;\n        }\n    \n        return arr3;\n    }\n}\n\n\n```\n\n:::\n\n_Time: O(n) Space:O(1)_\n\n>Example 4: 392. Is Subsequence.\nGiven two strings s and t, return true if s is a subsequence of t, or false otherwise.\n\n::: {.panel-tabset}\n## Java\n```{.java}\n\n public static boolean checkIfSubsequence(String s, String t){\n    int i =0;\n    int j =0;\n\n    while(i < s.length() && j<t.length()){\n        if(s.charAt(i)==t.charAt(j)){\n            i++;\n        }\n         \n        j++;\n        \n    }\n    return i == s.length();\n }\n\n}\n```\n\n:::\n\n_Time: O(n) Space:O(1)_\n\nA subsequence of a string is a sequence of characters that can be obtained by deleting some (or none) of the characters from the original string, while maintaining the relative order of the remaining characters. For example, \"ace\" is a subsequence of \"abcde\" while \"aec\" is not.\n\n\n## Two Pointers Examples\n\n>Reverse String Write a function that reverses a string. The input string is given as an array of characters s.\nYou must do this by modifying the input array in-place with O(1) extra memory\n\n\n::: {.panel-tabset}\n\n## Java\n\n```{.java}\n public static void reverseString(char[] s) {\n        int i = s.length-1; \n        int j= 0; \n        \n        while(i > j ){\n            char tmp = s[j];\n            s[j++]=s[i];\n            s[i--]=tmp;\n        }\n        System.out.println(s);\n        \n    }   \n```\n\n## Python\n```{.python}\n\nclass Solution(object):\n    def reverseString(self, s):\n    s.reverse()\n```\n\n:::\n\n>**Squares of a Sorted Array**\nGiven an integer array nums sorted in non-decreasing order, return an array of the squares of each number sorted in non-decreasing order.\n\n\n::: {.panel-tabset}\n\n## Java\n\n```{.java}\n    public int[] sortedSquares(int[] nums) {\n        \n        int left = 0;\n        int right = nums.length-1;\n\n        while(left <= right){\n        \n            int tmp = nums[left]*nums[left];\n            nums[left] = tmp;\n            left++;\n        }\n        Arrays.sort(nums);\n\n        return nums;\n    }\n```\n\n## Java\n```{.java}\n//After my first submission I realized this could be cleaner\n    public int[] sortedSquares(int[] nums) {\n        for(int i=0; i< nums.length;i++){\n            nums[i] = nums[i] * nums[i];\n        }\n        Arrays.sort(nums);\n        return nums;\n    }\n```\n## Python\n```{.python}\ndef sortedSquares(self, nums: List[int]) -> List[int]:\n  for i in range(len(nums)):\n      nums[i] = nums[i] *nums[i]\n  nums = sorted(nums)\n  return nums\n```\n\n:::\n\n# Sliding Window \n_Similar to two pointers they're iterables with ordered elements._\n\n## Subarrays\n\nContinuous section of the array. All the elements must be **adjacent to each other and in their original order**\n\nExample: [1,2,3,4]\n\n- [1],[2],[3],[4]\n- [1,2],[2,3],[3,4]\n- [1,2,3], [2,3,4]\n\n\nIdentifying when to use this:\n\nThe problem will:\n  1. Explicitly or implicitly define criteria that makes a subarray \"valid\". \n  2. Ask you to find valid subarrays in some way \n    - find the \"best\" valid subarray \n    - finding the number of valid subarrays \n    \n## Psudocode\n```{.java}\nfunction fn(nums, k):\n    left = 0\n    curr = 0\n    answer = 0\n    for (int right = 0; right < nums.length; right++):\n        curr += nums[right]\n        while (curr > k):\n            curr -= nums[left]\n            left++\n\n        answer = max(answer, right - left + 1)\n\n    return answer\n```\n\n>Example 1: Given an array of positive integers nums and an integer k, find the length of the longest subarray whose sum is less than or equal to k. This is the problem we have been talking about above. We will now formally solve it.\n\n\n## Java\n```{.java}\n    public static int subarray(int[] nums, int k) {\n        int left =0;\n        int sum = 0;\n        int answer = 0;\n\n        for(int right =0; right<nums.length;right++){\n            sum += nums[right];\n            while(sum > k){\n                sum -= nums[left];\n                left++;\n            }\n            answer = Math.max(answer, right - left + 1);\n\n        }\n```\n\n>Example 2: You are given a binary string s (a string containing only \"0\" and \"1\"). You may choose up to one \"0\" and flip it to a \"1\". What is the length of the longest substring achievable that contains only \"1\"?\nFor example, given s = \"1101100111\", the answer is 5. If you perform the flip at index 2, the string becomes 1111100111.\n\n::: {.panel-tabset}\n\n## Java\n\n```{.java}\npublic static int binarySubarray(String s) {\n    int left =0;\n    int counter = 0;\n    int answer = 0;\n\n    for(int i =0; i<s.length();i++){\n        if (s.charAt(i)== '0') {\n            counter++;\n\n        }\n\n        while(counter > 1){\n            if (s.charAt(left) == '0') {\n                counter--;\n            }\n\n            left++;\n        }\n\n        answer = Math.max(answer, i - left + 1);\n    }\n\n        \n        return answer;\n\n    }\n\n```\n\n## Python\n```{.python}\ndef binarySubarray(s):\n\n    left=counter=answer=0\n\n    for i in range(len(s)):\n        if s[i] ==\"0\":\n            counter +=1\n        while counter > 1:\n            if(s[left] == \"0\"):\n                counter -= 1\n            left += 1\n\n        ans = max(answer, i - left + 1)\n\n    return(ans)\n```\n\n:::\n\n## Number of Subarrays\n>**Example 3: 713. Subarray Product Less Than K.**\nGiven an array of positive integers nums and an integer k, return the number of subarrays where the product of all the elements in the subarray is strictly less than k.\nFor example, given the input nums = [10, 5, 2, 6], k = 100, the answer is 8. The subarrays with products less than k are:[10], [5], [2], [6], [10, 5], [5, 2], [2, 6], [5, 2, 6]\n\n```{.java}\npublic static int productLessThan(int[] nums, int k) {\n        int left =0;\n        int counter = 1;\n        int answer = 0;\n\n        if (k <= 1) {\n            return 0;\n        }\n        for(int right =0; right<nums.length;right++){\n            counter *= nums[right];\n            while(counter>=k){\n                counter /= nums[left]; //opposite of multiplication remove that element \n                left += 1;\n            }\n            answer += right -left +1;\n    }\n        return answer;\n\n    }\n\n```\n\n\n## Fixed window size\n\n## Psudocode\n```{.java}\nfunction fn(arr, k):\n    curr = some data to track the window\n\n    // build the first window\n    for (int i = 0; i < k; i++)\n        Do something with curr or other variables to build first window\n\n    ans = answer variable, probably equal to curr here depending on the problem\n    for (int i = k; i < arr.length; i++)\n        Add arr[i] to window\n        Remove arr[i - k] from window\n        Update ans\n\n    return ans\n```\n\n## Leetcode Problem \n\n>**Example 4**: Given an integer array nums and an integer k, find the sum of the subarray with the largest sum whose length is k.\n\n```{.java}\npublic static int productLessThan(int[] nums, int k) {\n        int left =0;\n        int counter = 1;\n        int answer = 0;\n\n        if (k <= 1) {\n            return 0;\n        }\n        for(int right =0; right<nums.length;right++){\n            counter *= nums[right];\n            while(counter>=k){\n                counter /= nums[left]; //opposite of multiplication remove that element \n                left += 1;\n            }\n            answer += right -left +1;\n    }\n        return answer;\n\n    }\n\n```\n\n\n**1004. Max Consecutive Ones III**: Given a binary array nums and an integer k, return the maximum number of consecutive 1's in the array if you can flip at most k 0's.\n\nExample 1:\nInput: nums = [1,1,1,0,0,0,1,1,1,1,0], k = 2\nOutput: 6\nExplanation: [1,1,1,0,0,**1**,1,1,1,1,**1**]\nBolded numbers were flipped from 0 to 1. The longest subarray is underlined..\n\n\n::: {.panel-tabset}\n\n## Java\n```{.java}\npublic static int productLessThan(int[] nums, int k) {\n        int left =0;\n        int counter = 1;\n        int answer = 0;\n\n        if (k <= 1) {\n            return 0;\n        }\n        for(int right =0; right<nums.length;right++){\n            counter *= nums[right];\n            while(counter>=k){\n                counter /= nums[left]; //opposite of multiplication remove that element \n                left += 1;\n            }\n            answer += right -left +1;\n    }\n        return answer;\n\n    }\n\n```\nTime complexity:O(n) Space complexity:O(1) _3ms Runtime Beats 79.28% of users with Java_\n:::\n\n\n# Prefix Sum\nPrefix sum is a technique that can be used on arrays (of numbers). The idea is to create an array prefix where prefix[i] is the sum of all elements up to the index i (inclusive). For example, given nums = [5, 2, 1, 6, 3, 8], we would have prefix = [5, 7, 8, 14, 17, 25].\n\n\n If we want the sum of the subarray from i to j (inclusive), then the answer is prefix[j] - prefix[i - 1], or prefix[j] - prefix[i] + nums[i] if you don't want to deal with the out of bounds case when i = 0.\n \n \n```{.java}\npublic boolean[] answerQueries(int[] nums, int[][] queries, int limit) {\n    int[] prefix = new int[nums.length];\n    prefix[0] = nums[0];\n\n    for (int i = 1; i < nums.length; i++) {\n        prefix[i] = prefix[i - 1] + nums[i];\n    }\n\n    boolean[] ans = new boolean[queries.length];\n    for (int i = 0; i < queries.length; i++) {\n        int x = queries[i][0], y = queries[i][1];\n        int curr = prefix[y] - prefix[x] + nums[x];\n        ans[i] = curr < limit;\n    }\n    \n    return ans;\n}\n```\n\n## Leetcode Problem \nGiven an array nums. We define a running sum of an array as runningSum[i] = sum(nums[0]…nums[i]). **Return the running sum of nums**\n\nExample 1:\nInput: nums = [1,2,3,4]\nOutput: [1,3,6,10]\nExplanation: Running sum is obtained as follows: [1, 1+2, 1+2+3, 1+2+3+4].\n\n::: {.panel-tabset}\n\n## Java\n```{.java}\n    private static int[] runningSum(int[] nums) {\n        int [] prefix = new int[nums.length];\n        prefix[0]=nums[0];\n        for(int i=1;i<nums.length;i++){\n            prefix[i] = nums[i]+prefix[i-1];\n        }\n        return prefix;\n\n    }\n\n```\nTime complexity:O(n) Space complexity:O(n) **It creates an additional array prefix of the same length as the input array nums. The size of the prefix array is proportional to the size of the input array, making the space complexity linear.**\n\n_Runtime 0ms Beats100.00% of users with Java_\n::: \n\n\n# More Common Patters\n\n## O(n) String Building\n::: {.panel-tabset}\n\n## Python\n```{.python}\ndef build_string(s):\n  arr=[] #declar a list\n  for c in s\n      arr.append(c) #add the characters to the list \n    return \"\".join(list) # convert the list to a string \n\n```\n_O(n)_\n\n## Java\n```{.java}\npublic string buildString(String s) {\n    StringBuilder sb = new StringBuilder(); //use string builder\n    for (int i = 0; i < s.length(); i++) {\n        sb.append(s.charAt(i)); // add character to the list\n    }\n    StringBuilder.toString() // convert list to string\n    return sb.toString();\n\n    \n```\n_O(n)_\n::: \n\n# Extra Leetcode Problems\n\n557. Reverse Words in a String III\nGiven a string s, reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.\n\n>Example 1:\nInput: s = \"Let's take LeetCode contest\"\nOutput: \"s'teL ekat edoCteeL tsetnoc\"\nExample 2:\n\n>Input: s = \"Mr Ding\"\nOutput: \"rM gniD\"\n\n\n::: {.panel-tabset}\n\n## Java\n```{.java}\nprivate static String reverseWords(String s) {\n\n        StringBuilder sb = new StringBuilder();\n        \n        int left=0;\n\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == ' ') {\n                // Reverse the word and append to StringBuilder\n                for (int j = i - 1; j >= left; j--) {\n                    sb.append(s.charAt(j));\n                }\n                // Append the space\n                sb.append(' ');\n                // Update the left pointer to the next character\n                left = i + 1;\n            } else if (i == s.length() - 1) {\n                // Reverse the last word and append to StringBuilder\n                for (int j = i; j >= left; j--) {\n                    sb.append(s.charAt(j));\n                }\n            }\n        }\n    \n        return sb.toString();\n\n        }\n```\n_Runtime 9ms Beats 44.51% of users with Java_\n::: \n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"markdown"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"html-math-method":"katex","css":["styles.css"],"output-file":"array-string.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.306","theme":{"light":["flatly","light.scss"],"dark":["darkly","dark.scss"]},"title":"Arrays and Strings","author":"Valentina Colorado","date":"2024-01-28","categories":["Java","Python","Data Structures","Algorithms","Arrays","Strings"],"image":"https://miro.medium.com/v2/resize:fit:1200/1*YWjJuLuXJULb-2IyYhqnXQ.gif","description":"Going over basic arrays and strings content and leetcode problems"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}